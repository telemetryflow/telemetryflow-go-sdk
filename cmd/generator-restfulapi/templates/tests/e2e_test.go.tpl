// Package tests provides end-to-end tests for {{.ProjectName}}.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package tests

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"sync"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"{{.ModulePath}}/tests/fixtures"
)

// =============================================================================
// E2E Test Server & Helpers
// =============================================================================

// TestServer represents a test server for E2E tests
type TestServer struct {
	Echo       *echo.Echo
	mu         sync.RWMutex
	requests   []RequestRecord
	startTime  time.Time
}

// RequestRecord tracks a request made to the test server
type RequestRecord struct {
	Method     string
	Path       string
	StatusCode int
	Duration   time.Duration
	Timestamp  time.Time
}

// NewTestServer creates a new test server
func NewTestServer() *TestServer {
	e := echo.New()
	return &TestServer{
		Echo:      e,
		requests:  make([]RequestRecord, 0),
		startTime: time.Now(),
	}
}

// Request makes a test request and records it
func (s *TestServer) Request(method, path string, body interface{}) *httptest.ResponseRecorder {
	start := time.Now()

	var reqBody *bytes.Buffer
	if body != nil {
		jsonBody, _ := json.Marshal(body)
		reqBody = bytes.NewBuffer(jsonBody)
	} else {
		reqBody = bytes.NewBuffer(nil)
	}

	req := httptest.NewRequest(method, path, reqBody)
	req.Header.Set("Content-Type", "application/json")
	rec := httptest.NewRecorder()

	s.Echo.ServeHTTP(rec, req)

	// Record the request
	s.mu.Lock()
	s.requests = append(s.requests, RequestRecord{
		Method:     method,
		Path:       path,
		StatusCode: rec.Code,
		Duration:   time.Since(start),
		Timestamp:  start,
	})
	s.mu.Unlock()

	return rec
}

// RequestWithHeaders makes a test request with custom headers
func (s *TestServer) RequestWithHeaders(method, path string, body interface{}, headers map[string]string) *httptest.ResponseRecorder {
	start := time.Now()

	var reqBody *bytes.Buffer
	if body != nil {
		jsonBody, _ := json.Marshal(body)
		reqBody = bytes.NewBuffer(jsonBody)
	} else {
		reqBody = bytes.NewBuffer(nil)
	}

	req := httptest.NewRequest(method, path, reqBody)
	req.Header.Set("Content-Type", "application/json")
	for key, value := range headers {
		req.Header.Set(key, value)
	}
	rec := httptest.NewRecorder()

	s.Echo.ServeHTTP(rec, req)

	// Record the request
	s.mu.Lock()
	s.requests = append(s.requests, RequestRecord{
		Method:     method,
		Path:       path,
		StatusCode: rec.Code,
		Duration:   time.Since(start),
		Timestamp:  start,
	})
	s.mu.Unlock()

	return rec
}

// GetRequests returns all recorded requests
func (s *TestServer) GetRequests() []RequestRecord {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return append([]RequestRecord{}, s.requests...)
}

// RequestCount returns the number of requests made
func (s *TestServer) RequestCount() int {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return len(s.requests)
}

// AverageResponseTime returns the average response time
func (s *TestServer) AverageResponseTime() time.Duration {
	s.mu.RLock()
	defer s.mu.RUnlock()

	if len(s.requests) == 0 {
		return 0
	}

	var total time.Duration
	for _, r := range s.requests {
		total += r.Duration
	}
	return total / time.Duration(len(s.requests))
}

// Reset clears all recorded requests
func (s *TestServer) Reset() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.requests = make([]RequestRecord, 0)
	s.startTime = time.Now()
}

// =============================================================================
// E2E Health Check Tests
// =============================================================================

func TestE2EHealthCheck(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	// Setup health endpoint
	server.Echo.GET("/health", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]interface{}{
			"status":    "healthy",
			"service":   "{{.ServiceName}}",
			"version":   "{{.ServiceVersion}}",
			"timestamp": time.Now().Format(time.RFC3339),
		})
	})

	t.Run("health check should return 200", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/health", nil)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "healthy", response["status"])
		assert.Equal(t, "{{.ServiceName}}", response["service"])
		assert.Equal(t, "{{.ServiceVersion}}", response["version"])
		assert.NotEmpty(t, response["timestamp"])
	})

	t.Run("health check should be fast", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/health", nil)
		require.Equal(t, http.StatusOK, rec.Code)

		// Get the last request
		requests := server.GetRequests()
		lastRequest := requests[len(requests)-1]

		assert.Less(t, lastRequest.Duration, 100*time.Millisecond)
	})
}

// =============================================================================
// E2E API Endpoints Tests
// =============================================================================

func TestE2EAPIEndpoints(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	// Setup API v1 group
	api := server.Echo.Group("/api/v1")

	api.GET("/ping", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"message": "pong"})
	})

	t.Run("ping endpoint should return pong", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/api/v1/ping", nil)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]string
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "pong", response["message"])
	})
}

// =============================================================================
// E2E CRUD Operations Tests
// =============================================================================

func TestE2ECRUDOperations(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	// In-memory storage for E2E testing
	storage := make(map[string]interface{})
	var storageMu sync.RWMutex

	// Setup CRUD endpoints
	api := server.Echo.Group("/api/v1")

	// Create
	api.POST("/entities", func(c echo.Context) error {
		var entity map[string]interface{}
		if err := c.Bind(&entity); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}

		id := uuid.New().String()
		entity["id"] = id
		entity["created_at"] = time.Now().Format(time.RFC3339)

		storageMu.Lock()
		storage[id] = entity
		storageMu.Unlock()

		return c.JSON(http.StatusCreated, entity)
	})

	// Read
	api.GET("/entities/:id", func(c echo.Context) error {
		id := c.Param("id")

		storageMu.RLock()
		entity, exists := storage[id]
		storageMu.RUnlock()

		if !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Entity not found")
		}

		return c.JSON(http.StatusOK, entity)
	})

	// List
	api.GET("/entities", func(c echo.Context) error {
		storageMu.RLock()
		entities := make([]interface{}, 0, len(storage))
		for _, e := range storage {
			entities = append(entities, e)
		}
		storageMu.RUnlock()

		return c.JSON(http.StatusOK, map[string]interface{}{
			"data":  entities,
			"total": len(entities),
		})
	})

	// Update
	api.PUT("/entities/:id", func(c echo.Context) error {
		id := c.Param("id")

		storageMu.RLock()
		_, exists := storage[id]
		storageMu.RUnlock()

		if !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Entity not found")
		}

		var update map[string]interface{}
		if err := c.Bind(&update); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}

		update["id"] = id
		update["updated_at"] = time.Now().Format(time.RFC3339)

		storageMu.Lock()
		storage[id] = update
		storageMu.Unlock()

		return c.JSON(http.StatusOK, update)
	})

	// Delete
	api.DELETE("/entities/:id", func(c echo.Context) error {
		id := c.Param("id")

		storageMu.Lock()
		defer storageMu.Unlock()

		if _, exists := storage[id]; !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Entity not found")
		}

		delete(storage, id)
		return c.NoContent(http.StatusNoContent)
	})

	var createdID string

	t.Run("should create entity", func(t *testing.T) {
		entity := fixtures.GetSampleEntityData()
		rec := server.Request(http.MethodPost, "/api/v1/entities", entity)

		require.Equal(t, http.StatusCreated, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.NotEmpty(t, response["id"])
		createdID = response["id"].(string)
	})

	t.Run("should read created entity", func(t *testing.T) {
		require.NotEmpty(t, createdID, "No entity was created")

		rec := server.Request(http.MethodGet, fmt.Sprintf("/api/v1/entities/%s", createdID), nil)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, createdID, response["id"])
	})

	t.Run("should list entities", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/api/v1/entities", nil)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.GreaterOrEqual(t, response["total"].(float64), float64(1))
	})

	t.Run("should update entity", func(t *testing.T) {
		require.NotEmpty(t, createdID, "No entity was created")

		update := map[string]interface{}{
			"name":        "Updated Name",
			"description": "Updated Description",
		}
		rec := server.Request(http.MethodPut, fmt.Sprintf("/api/v1/entities/%s", createdID), update)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "Updated Name", response["name"])
		assert.NotEmpty(t, response["updated_at"])
	})

	t.Run("should delete entity", func(t *testing.T) {
		require.NotEmpty(t, createdID, "No entity was created")

		rec := server.Request(http.MethodDelete, fmt.Sprintf("/api/v1/entities/%s", createdID), nil)

		assert.Equal(t, http.StatusNoContent, rec.Code)
	})

	t.Run("should return 404 for deleted entity", func(t *testing.T) {
		require.NotEmpty(t, createdID, "No entity was created")

		rec := server.Request(http.MethodGet, fmt.Sprintf("/api/v1/entities/%s", createdID), nil)

		assert.Equal(t, http.StatusNotFound, rec.Code)
	})
}

// =============================================================================
// E2E Error Handling Tests
// =============================================================================

func TestE2EErrorHandling(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	server.Echo.GET("/error", func(c echo.Context) error {
		return echo.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")
	})

	server.Echo.GET("/not-found", func(c echo.Context) error {
		return echo.NewHTTPError(http.StatusNotFound, "Resource not found")
	})

	server.Echo.GET("/bad-request", func(c echo.Context) error {
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid request")
	})

	server.Echo.GET("/unauthorized", func(c echo.Context) error {
		return echo.NewHTTPError(http.StatusUnauthorized, "Unauthorized")
	})

	server.Echo.GET("/forbidden", func(c echo.Context) error {
		return echo.NewHTTPError(http.StatusForbidden, "Forbidden")
	})

	testCases := []struct {
		name           string
		path           string
		expectedStatus int
		expectedError  string
	}{
		{
			name:           "internal server error",
			path:           "/error",
			expectedStatus: http.StatusInternalServerError,
			expectedError:  "Internal Server Error",
		},
		{
			name:           "not found error",
			path:           "/not-found",
			expectedStatus: http.StatusNotFound,
			expectedError:  "Resource not found",
		},
		{
			name:           "bad request error",
			path:           "/bad-request",
			expectedStatus: http.StatusBadRequest,
			expectedError:  "Invalid request",
		},
		{
			name:           "unauthorized error",
			path:           "/unauthorized",
			expectedStatus: http.StatusUnauthorized,
			expectedError:  "Unauthorized",
		},
		{
			name:           "forbidden error",
			path:           "/forbidden",
			expectedStatus: http.StatusForbidden,
			expectedError:  "Forbidden",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			rec := server.Request(http.MethodGet, tc.path, nil)

			assert.Equal(t, tc.expectedStatus, rec.Code)
			assert.Contains(t, rec.Body.String(), tc.expectedError)
		})
	}
}

// =============================================================================
// E2E Validation Tests
// =============================================================================

func TestE2EValidation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	type CreateRequest struct {
		Name  string `json:"name" validate:"required"`
		Email string `json:"email" validate:"required,email"`
		Age   int    `json:"age" validate:"required,gte=0,lte=150"`
	}

	server.Echo.POST("/validate", func(c echo.Context) error {
		var req CreateRequest
		if err := c.Bind(&req); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}

		// Simple validation
		if req.Name == "" {
			return echo.NewHTTPError(http.StatusBadRequest, "Name is required")
		}
		if req.Email == "" {
			return echo.NewHTTPError(http.StatusBadRequest, "Email is required")
		}

		return c.JSON(http.StatusCreated, map[string]string{
			"message": "Created successfully",
		})
	})

	validationTestCases := []struct {
		name           string
		body           map[string]interface{}
		expectedStatus int
	}{
		{
			name:           "valid request",
			body:           map[string]interface{}{"name": "Test User", "email": "test@example.com", "age": 25},
			expectedStatus: http.StatusCreated,
		},
		{
			name:           "missing name",
			body:           map[string]interface{}{"email": "test@example.com", "age": 25},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name:           "missing email",
			body:           map[string]interface{}{"name": "Test User", "age": 25},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name:           "empty body",
			body:           map[string]interface{}{},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tc := range validationTestCases {
		t.Run(tc.name, func(t *testing.T) {
			rec := server.Request(http.MethodPost, "/validate", tc.body)
			assert.Equal(t, tc.expectedStatus, rec.Code)
		})
	}
}

// =============================================================================
// E2E Authentication Flow Tests
// =============================================================================

func TestE2EAuthenticationFlow(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	// Simple token storage for testing
	validTokens := map[string]string{
		"valid-token": "user123",
	}

	// Auth middleware simulation
	authMiddleware := func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			token := c.Request().Header.Get("Authorization")
			if token == "" {
				return echo.NewHTTPError(http.StatusUnauthorized, "Missing authorization header")
			}

			// Remove "Bearer " prefix
			if len(token) > 7 && token[:7] == "Bearer " {
				token = token[7:]
			}

			if _, exists := validTokens[token]; !exists {
				return echo.NewHTTPError(http.StatusUnauthorized, "Invalid token")
			}

			return next(c)
		}
	}

	// Protected group
	protected := server.Echo.Group("/api/v1", authMiddleware)
	protected.GET("/profile", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{
			"user_id": "user123",
			"name":    "Test User",
		})
	})

	t.Run("should reject request without token", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/api/v1/profile", nil)
		assert.Equal(t, http.StatusUnauthorized, rec.Code)
	})

	t.Run("should reject request with invalid token", func(t *testing.T) {
		rec := server.RequestWithHeaders(http.MethodGet, "/api/v1/profile", nil, map[string]string{
			"Authorization": "Bearer invalid-token",
		})
		assert.Equal(t, http.StatusUnauthorized, rec.Code)
	})

	t.Run("should accept request with valid token", func(t *testing.T) {
		rec := server.RequestWithHeaders(http.MethodGet, "/api/v1/profile", nil, map[string]string{
			"Authorization": "Bearer valid-token",
		})
		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]string
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Equal(t, "user123", response["user_id"])
	})
}

// =============================================================================
// E2E Concurrent Request Tests
// =============================================================================

func TestE2EConcurrentRequests(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	server.Echo.GET("/concurrent", func(c echo.Context) error {
		// Simulate some work
		time.Sleep(10 * time.Millisecond)
		return c.JSON(http.StatusOK, map[string]string{"status": "ok"})
	})

	t.Run("should handle concurrent requests", func(t *testing.T) {
		const numRequests = 50
		var wg sync.WaitGroup
		errors := make(chan error, numRequests)

		for i := 0; i < numRequests; i++ {
			wg.Add(1)
			go func() {
				defer wg.Done()
				rec := server.Request(http.MethodGet, "/concurrent", nil)
				if rec.Code != http.StatusOK {
					errors <- fmt.Errorf("unexpected status: %d", rec.Code)
				}
			}()
		}

		wg.Wait()
		close(errors)

		for err := range errors {
			t.Error(err)
		}

		assert.Equal(t, numRequests, server.RequestCount())
	})
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkE2EHealthCheck(b *testing.B) {
	server := NewTestServer()

	server.Echo.GET("/health", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"status": "healthy"})
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		server.Request(http.MethodGet, "/health", nil)
	}
}

func BenchmarkE2ECreateEntity(b *testing.B) {
	server := NewTestServer()

	server.Echo.POST("/entities", func(c echo.Context) error {
		var entity map[string]interface{}
		if err := c.Bind(&entity); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}
		entity["id"] = uuid.New().String()
		return c.JSON(http.StatusCreated, entity)
	})

	entity := map[string]interface{}{
		"name":        "Benchmark Entity",
		"description": "Entity for benchmarking",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		server.Request(http.MethodPost, "/entities", entity)
	}
}

func BenchmarkE2EJSONParsing(b *testing.B) {
	server := NewTestServer()

	largeEntity := map[string]interface{}{
		"name":        "Large Entity",
		"description": "Entity with many fields",
		"metadata":    make(map[string]interface{}),
	}

	// Add many fields
	for i := 0; i < 100; i++ {
		largeEntity["metadata"].(map[string]interface{})[fmt.Sprintf("field_%d", i)] = fmt.Sprintf("value_%d", i)
	}

	server.Echo.POST("/parse", func(c echo.Context) error {
		var entity map[string]interface{}
		if err := c.Bind(&entity); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}
		return c.JSON(http.StatusOK, entity)
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		server.Request(http.MethodPost, "/parse", largeEntity)
	}
}

func BenchmarkE2EConcurrentRequests(b *testing.B) {
	server := NewTestServer()

	server.Echo.GET("/bench-concurrent", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{"status": "ok"})
	})

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			server.Request(http.MethodGet, "/bench-concurrent", nil)
		}
	})
}

// =============================================================================
// E2E Timeout Tests
// =============================================================================

func TestE2ERequestTimeout(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	server.Echo.GET("/slow", func(c echo.Context) error {
		ctx := c.Request().Context()
		select {
		case <-time.After(100 * time.Millisecond):
			return c.JSON(http.StatusOK, map[string]string{"status": "completed"})
		case <-ctx.Done():
			return echo.NewHTTPError(http.StatusRequestTimeout, "Request timeout")
		}
	})

	t.Run("should complete before timeout", func(t *testing.T) {
		ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
		defer cancel()

		_ = ctx // Use for actual request context if needed
		rec := server.Request(http.MethodGet, "/slow", nil)
		assert.Equal(t, http.StatusOK, rec.Code)
	})
}

// =============================================================================
// E2E Response Format Tests
// =============================================================================

func TestE2EResponseFormats(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping E2E test in short mode")
	}

	server := NewTestServer()

	server.Echo.GET("/json", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]interface{}{
			"data":    []string{"item1", "item2"},
			"message": "Success",
		})
	})

	server.Echo.GET("/text", func(c echo.Context) error {
		return c.String(http.StatusOK, "Plain text response")
	})

	t.Run("should return valid JSON", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/json", nil)

		assert.Equal(t, http.StatusOK, rec.Code)
		assert.Contains(t, rec.Header().Get("Content-Type"), "application/json")

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.Contains(t, response, "data")
		assert.Contains(t, response, "message")
	})

	t.Run("should return plain text", func(t *testing.T) {
		rec := server.Request(http.MethodGet, "/text", nil)

		assert.Equal(t, http.StatusOK, rec.Code)
		assert.Contains(t, rec.Header().Get("Content-Type"), "text/plain")
		assert.Equal(t, "Plain text response", rec.Body.String())
	})
}
