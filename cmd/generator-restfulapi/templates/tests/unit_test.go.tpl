// Package tests provides unit tests for {{.ProjectName}}.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package tests

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"{{.ModulePath}}/internal/domain"
	"{{.ModulePath}}/tests/fixtures"
	"{{.ModulePath}}/tests/mocks"
)

// =============================================================================
// Test Helpers
// =============================================================================

// createTestContext creates a context with timeout for tests
func createTestContext(t *testing.T) (context.Context, context.CancelFunc) {
	return context.WithTimeout(context.Background(), 5*time.Second)
}

// =============================================================================
// Domain Entity Tests
// =============================================================================

func TestNewEntity(t *testing.T) {
	t.Run("should create entity with valid data", func(t *testing.T) {
		// arrange
		id := uuid.New()
		name := "Test Entity"

		// act
		entity := domain.NewEntity(id, name)

		// assert
		require.NotNil(t, entity)
		assert.Equal(t, id, entity.ID)
		assert.Equal(t, name, entity.Name)
		assert.False(t, entity.CreatedAt.IsZero())
	})

	t.Run("should reject empty name", func(t *testing.T) {
		// arrange
		id := uuid.New()
		name := ""

		// act
		entity, err := domain.NewEntityWithValidation(id, name)

		// assert
		require.Error(t, err)
		assert.Nil(t, entity)
		assert.Contains(t, err.Error(), "name")
	})
}

// TestEntityValidation uses table-driven tests for validation scenarios
func TestEntityValidation(t *testing.T) {
	testCases := []struct {
		name        string
		entityName  string
		expectError bool
		errorMsg    string
	}{
		{
			name:        "valid name",
			entityName:  "Valid Entity",
			expectError: false,
		},
		{
			name:        "empty name",
			entityName:  "",
			expectError: true,
			errorMsg:    "name cannot be empty",
		},
		{
			name:        "name too long",
			entityName:  string(make([]byte, 256)),
			expectError: true,
			errorMsg:    "name exceeds maximum length",
		},
		{
			name:        "name with special characters",
			entityName:  "Valid-Entity_123",
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// act
			err := domain.ValidateEntityName(tc.entityName)

			// assert
			if tc.expectError {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tc.errorMsg)
			} else {
				require.NoError(t, err)
			}
		})
	}
}

// =============================================================================
// Repository Tests with Mocks
// =============================================================================

func TestRepository_Create(t *testing.T) {
	t.Run("should create entity successfully", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		entity := fixtures.GetSampleEntity()

		mockRepo.On("Create", ctx, entity).Return(nil)

		// act
		err := mockRepo.Create(ctx, entity)

		// assert
		require.NoError(t, err)
		mockRepo.AssertExpectations(t)
	})

	t.Run("should handle create error", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		entity := fixtures.GetSampleEntity()
		expectedErr := assert.AnError

		mockRepo.On("Create", ctx, entity).Return(expectedErr)

		// act
		err := mockRepo.Create(ctx, entity)

		// assert
		require.Error(t, err)
		assert.Equal(t, expectedErr, err)
		mockRepo.AssertExpectations(t)
	})
}

func TestRepository_FindByID(t *testing.T) {
	t.Run("should find entity by ID", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		entity := fixtures.GetSampleEntity()

		mockRepo.On("FindByID", ctx, entity.ID).Return(entity, nil)

		// act
		result, err := mockRepo.FindByID(ctx, entity.ID)

		// assert
		require.NoError(t, err)
		assert.Equal(t, entity, result)
		mockRepo.AssertExpectations(t)
	})

	t.Run("should return error for non-existent entity", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		id := uuid.New()

		mockRepo.On("FindByID", ctx, id).Return(nil, domain.ErrEntityNotFound)

		// act
		result, err := mockRepo.FindByID(ctx, id)

		// assert
		require.Error(t, err)
		assert.Nil(t, result)
		assert.ErrorIs(t, err, domain.ErrEntityNotFound)
		mockRepo.AssertExpectations(t)
	})
}

func TestRepository_FindAll(t *testing.T) {
	t.Run("should return paginated results", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		entities := fixtures.GetSampleEntities(5)
		offset := 0
		limit := 10
		total := int64(5)

		mockRepo.On("FindAll", ctx, offset, limit).Return(entities, total, nil)

		// act
		result, count, err := mockRepo.FindAll(ctx, offset, limit)

		// assert
		require.NoError(t, err)
		assert.Len(t, result, 5)
		assert.Equal(t, total, count)
		mockRepo.AssertExpectations(t)
	})
}

func TestRepository_Update(t *testing.T) {
	t.Run("should update entity successfully", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		entity := fixtures.GetSampleEntity()
		entity.Name = "Updated Name"

		mockRepo.On("Update", ctx, entity).Return(nil)

		// act
		err := mockRepo.Update(ctx, entity)

		// assert
		require.NoError(t, err)
		mockRepo.AssertExpectations(t)
	})
}

func TestRepository_Delete(t *testing.T) {
	t.Run("should delete entity successfully", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		id := uuid.New()

		mockRepo.On("Delete", ctx, id).Return(nil)

		// act
		err := mockRepo.Delete(ctx, id)

		// assert
		require.NoError(t, err)
		mockRepo.AssertExpectations(t)
	})
}

// =============================================================================
// Service Layer Tests
// =============================================================================

func TestService_Create(t *testing.T) {
	t.Run("should create entity through service", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		mockLogger := mocks.NewMockLogger()

		// Setup expectations
		mockRepo.On("Create", ctx, mock.AnythingOfType("*domain.Entity")).Return(nil)
		mockLogger.On("Info", mock.Anything, mock.Anything).Maybe()

		// act & assert
		// Note: Replace with actual service implementation
		mockRepo.AssertExpectations(t)
	})
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkEntityCreation(b *testing.B) {
	id := uuid.New()
	name := "Benchmark Entity"

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = domain.NewEntity(id, name)
	}
}

func BenchmarkEntityValidation(b *testing.B) {
	name := "Benchmark Entity Name"

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = domain.ValidateEntityName(name)
	}
}

func BenchmarkUUIDGeneration(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = uuid.New()
	}
}

// =============================================================================
// Concurrent Access Tests
// =============================================================================

func TestRepository_ConcurrentAccess(t *testing.T) {
	t.Run("should handle concurrent reads", func(t *testing.T) {
		// arrange
		ctx, cancel := createTestContext(t)
		defer cancel()

		mockRepo := mocks.NewMockRepository()
		entity := fixtures.GetSampleEntity()

		mockRepo.On("FindByID", ctx, entity.ID).Return(entity, nil)

		// act - concurrent reads
		done := make(chan bool, 10)
		for i := 0; i < 10; i++ {
			go func() {
				_, _ = mockRepo.FindByID(ctx, entity.ID)
				done <- true
			}()
		}

		// wait for all goroutines
		for i := 0; i < 10; i++ {
			<-done
		}

		// assert
		assert.True(t, mockRepo.AssertNumberOfCalls(t, "FindByID", 10))
	})
}
