// Package mocks provides mock implementations for testing.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package mocks

import (
	"context"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/mock"
)

// =============================================================================
// Mock Repository with State Tracking
// =============================================================================

// OperationRecord represents a recorded operation
type OperationRecord struct {
	Operation string
	EntityID  uuid.UUID
	Entity    interface{}
	Timestamp time.Time
}

// MockRepository is a mock repository implementation with state tracking
type MockRepository struct {
	mock.Mock
	mu sync.RWMutex

	// Internal state tracking
	data        map[uuid.UUID]interface{}
	operations  []OperationRecord
	createCount int
	readCount   int
	updateCount int
	deleteCount int
}

// NewMockRepository creates a new mock repository
func NewMockRepository() *MockRepository {
	return &MockRepository{
		data:       make(map[uuid.UUID]interface{}),
		operations: make([]OperationRecord, 0),
	}
}

// Create mocks creating an entity
func (m *MockRepository) Create(ctx context.Context, entity interface{}) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.createCount++
	m.operations = append(m.operations, OperationRecord{
		Operation: "create",
		Entity:    entity,
		Timestamp: time.Now(),
	})

	args := m.Called(ctx, entity)
	return args.Error(0)
}

// FindByID mocks finding an entity by ID
func (m *MockRepository) FindByID(ctx context.Context, id uuid.UUID) (interface{}, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.readCount++
	m.operations = append(m.operations, OperationRecord{
		Operation: "find_by_id",
		EntityID:  id,
		Timestamp: time.Now(),
	})

	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0), args.Error(1)
}

// FindAll mocks finding all entities
func (m *MockRepository) FindAll(ctx context.Context, offset, limit int) ([]interface{}, int64, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.readCount++
	m.operations = append(m.operations, OperationRecord{
		Operation: "find_all",
		Timestamp: time.Now(),
	})

	args := m.Called(ctx, offset, limit)
	if args.Get(0) == nil {
		return nil, 0, args.Error(2)
	}
	return args.Get(0).([]interface{}), args.Get(1).(int64), args.Error(2)
}

// Update mocks updating an entity
func (m *MockRepository) Update(ctx context.Context, entity interface{}) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.updateCount++
	m.operations = append(m.operations, OperationRecord{
		Operation: "update",
		Entity:    entity,
		Timestamp: time.Now(),
	})

	args := m.Called(ctx, entity)
	return args.Error(0)
}

// Delete mocks deleting an entity
func (m *MockRepository) Delete(ctx context.Context, id uuid.UUID) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.deleteCount++
	m.operations = append(m.operations, OperationRecord{
		Operation: "delete",
		EntityID:  id,
		Timestamp: time.Now(),
	})

	args := m.Called(ctx, id)
	return args.Error(0)
}

// =============================================================================
// State Inspection Methods
// =============================================================================

// GetOperations returns all recorded operations
func (m *MockRepository) GetOperations() []OperationRecord {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return append([]OperationRecord{}, m.operations...)
}

// GetOperationsByType returns operations filtered by type
func (m *MockRepository) GetOperationsByType(opType string) []OperationRecord {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var result []OperationRecord
	for _, op := range m.operations {
		if op.Operation == opType {
			result = append(result, op)
		}
	}
	return result
}

// CreateCount returns the number of create operations
func (m *MockRepository) CreateCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.createCount
}

// ReadCount returns the number of read operations
func (m *MockRepository) ReadCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.readCount
}

// UpdateCount returns the number of update operations
func (m *MockRepository) UpdateCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.updateCount
}

// DeleteCount returns the number of delete operations
func (m *MockRepository) DeleteCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.deleteCount
}

// TotalOperations returns the total number of operations
func (m *MockRepository) TotalOperations() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return len(m.operations)
}

// Reset clears all tracked data
func (m *MockRepository) Reset() {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.data = make(map[uuid.UUID]interface{})
	m.operations = make([]OperationRecord, 0)
	m.createCount = 0
	m.readCount = 0
	m.updateCount = 0
	m.deleteCount = 0
}

// =============================================================================
// Mock Logger with State Tracking
// =============================================================================

// LogEntry represents a log entry
type LogEntry struct {
	Level     string
	Message   string
	Fields    []interface{}
	Timestamp time.Time
}

// MockLogger is a mock logger implementation with state tracking
type MockLogger struct {
	mock.Mock
	mu sync.RWMutex

	entries    []LogEntry
	infoCount  int
	debugCount int
	warnCount  int
	errorCount int
}

// NewMockLogger creates a new mock logger
func NewMockLogger() *MockLogger {
	return &MockLogger{
		entries: make([]LogEntry, 0),
	}
}

// Info mocks info logging
func (m *MockLogger) Info(msg string, fields ...interface{}) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.infoCount++
	m.entries = append(m.entries, LogEntry{
		Level:     "info",
		Message:   msg,
		Fields:    fields,
		Timestamp: time.Now(),
	})
	m.Called(msg, fields)
}

// Error mocks error logging
func (m *MockLogger) Error(msg string, fields ...interface{}) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.errorCount++
	m.entries = append(m.entries, LogEntry{
		Level:     "error",
		Message:   msg,
		Fields:    fields,
		Timestamp: time.Now(),
	})
	m.Called(msg, fields)
}

// Debug mocks debug logging
func (m *MockLogger) Debug(msg string, fields ...interface{}) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.debugCount++
	m.entries = append(m.entries, LogEntry{
		Level:     "debug",
		Message:   msg,
		Fields:    fields,
		Timestamp: time.Now(),
	})
	m.Called(msg, fields)
}

// Warn mocks warn logging
func (m *MockLogger) Warn(msg string, fields ...interface{}) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.warnCount++
	m.entries = append(m.entries, LogEntry{
		Level:     "warn",
		Message:   msg,
		Fields:    fields,
		Timestamp: time.Now(),
	})
	m.Called(msg, fields)
}

// =============================================================================
// Logger State Inspection Methods
// =============================================================================

// GetEntries returns all log entries
func (m *MockLogger) GetEntries() []LogEntry {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return append([]LogEntry{}, m.entries...)
}

// GetEntriesByLevel returns log entries filtered by level
func (m *MockLogger) GetEntriesByLevel(level string) []LogEntry {
	m.mu.RLock()
	defer m.mu.RUnlock()

	var result []LogEntry
	for _, entry := range m.entries {
		if entry.Level == level {
			result = append(result, entry)
		}
	}
	return result
}

// GetMessages returns all log messages
func (m *MockLogger) GetMessages() []string {
	m.mu.RLock()
	defer m.mu.RUnlock()

	messages := make([]string, len(m.entries))
	for i, entry := range m.entries {
		messages[i] = entry.Message
	}
	return messages
}

// InfoCount returns the number of info logs
func (m *MockLogger) InfoCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.infoCount
}

// DebugCount returns the number of debug logs
func (m *MockLogger) DebugCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.debugCount
}

// WarnCount returns the number of warn logs
func (m *MockLogger) WarnCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.warnCount
}

// ErrorCount returns the number of error logs
func (m *MockLogger) ErrorCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.errorCount
}

// TotalLogs returns the total number of log entries
func (m *MockLogger) TotalLogs() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return len(m.entries)
}

// HasMessage checks if a message was logged
func (m *MockLogger) HasMessage(msg string) bool {
	m.mu.RLock()
	defer m.mu.RUnlock()

	for _, entry := range m.entries {
		if entry.Message == msg {
			return true
		}
	}
	return false
}

// Reset clears all logged entries
func (m *MockLogger) Reset() {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.entries = make([]LogEntry, 0)
	m.infoCount = 0
	m.debugCount = 0
	m.warnCount = 0
	m.errorCount = 0
}

// =============================================================================
// Mock Validator
// =============================================================================

// MockValidator is a mock validator implementation
type MockValidator struct {
	mock.Mock
	mu sync.RWMutex

	validationCount int
	failedCount     int
}

// NewMockValidator creates a new mock validator
func NewMockValidator() *MockValidator {
	return &MockValidator{}
}

// Validate mocks validation
func (m *MockValidator) Validate(i interface{}) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.validationCount++
	args := m.Called(i)
	err := args.Error(0)
	if err != nil {
		m.failedCount++
	}
	return err
}

// ValidationCount returns the number of validations
func (m *MockValidator) ValidationCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.validationCount
}

// FailedCount returns the number of failed validations
func (m *MockValidator) FailedCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.failedCount
}

// Reset clears validation counts
func (m *MockValidator) Reset() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.validationCount = 0
	m.failedCount = 0
}

// =============================================================================
// Mock HTTP Client with Request Tracking
// =============================================================================

// HTTPRequest represents a recorded HTTP request
type HTTPRequest struct {
	Method      string
	URL         string
	Body        interface{}
	Headers     map[string]string
	Timestamp   time.Time
}

// MockHTTPClient is a mock HTTP client implementation
type MockHTTPClient struct {
	mock.Mock
	mu sync.RWMutex

	requests     []HTTPRequest
	requestCount int
}

// NewMockHTTPClient creates a new mock HTTP client
func NewMockHTTPClient() *MockHTTPClient {
	return &MockHTTPClient{
		requests: make([]HTTPRequest, 0),
	}
}

// Do mocks HTTP request execution
func (m *MockHTTPClient) Do(req interface{}) (interface{}, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.requestCount++
	m.requests = append(m.requests, HTTPRequest{
		Timestamp: time.Now(),
	})

	args := m.Called(req)
	return args.Get(0), args.Error(1)
}

// GetRequests returns all recorded requests
func (m *MockHTTPClient) GetRequests() []HTTPRequest {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return append([]HTTPRequest{}, m.requests...)
}

// RequestCount returns the number of requests made
func (m *MockHTTPClient) RequestCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.requestCount
}

// Reset clears all tracked requests
func (m *MockHTTPClient) Reset() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.requests = make([]HTTPRequest, 0)
	m.requestCount = 0
}

// =============================================================================
// Mock Service with Command Tracking
// =============================================================================

// Command represents a command that was executed
type Command struct {
	Name       string
	Args       interface{}
	Timestamp  time.Time
}

// MockCommandHandler is a mock command handler
type MockCommandHandler struct {
	mock.Mock
	mu sync.RWMutex

	commands        []Command
	initialized     bool
	shutdownCalled  bool
}

// NewMockCommandHandler creates a new mock command handler
func NewMockCommandHandler() *MockCommandHandler {
	return &MockCommandHandler{
		commands: make([]Command, 0),
	}
}

// Handle mocks handling a command
func (m *MockCommandHandler) Handle(ctx context.Context, cmd interface{}) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.commands = append(m.commands, Command{
		Args:      cmd,
		Timestamp: time.Now(),
	})

	args := m.Called(ctx, cmd)
	return args.Error(0)
}

// Initialize marks the handler as initialized
func (m *MockCommandHandler) Initialize(ctx context.Context) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.initialized = true
	args := m.Called(ctx)
	return args.Error(0)
}

// Shutdown marks the handler as shut down
func (m *MockCommandHandler) Shutdown(ctx context.Context) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.shutdownCalled = true
	args := m.Called(ctx)
	return args.Error(0)
}

// IsInitialized returns whether the handler is initialized
func (m *MockCommandHandler) IsInitialized() bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.initialized
}

// ShutdownCalled returns whether shutdown was called
func (m *MockCommandHandler) ShutdownCalled() bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.shutdownCalled
}

// GetCommands returns all executed commands
func (m *MockCommandHandler) GetCommands() []Command {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return append([]Command{}, m.commands...)
}

// CommandCount returns the number of commands executed
func (m *MockCommandHandler) CommandCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return len(m.commands)
}

// Reset clears all tracked state
func (m *MockCommandHandler) Reset() {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.commands = make([]Command, 0)
	m.initialized = false
	m.shutdownCalled = false
}

// =============================================================================
// Mock Cache with Hit/Miss Tracking
// =============================================================================

// MockCache is a mock cache implementation
type MockCache struct {
	mock.Mock
	mu sync.RWMutex

	data      map[string]interface{}
	hitCount  int
	missCount int
	setCount  int
}

// NewMockCache creates a new mock cache
func NewMockCache() *MockCache {
	return &MockCache{
		data: make(map[string]interface{}),
	}
}

// Get mocks getting a value from cache
func (m *MockCache) Get(ctx context.Context, key string) (interface{}, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	args := m.Called(ctx, key)
	if args.Get(0) != nil {
		m.hitCount++
	} else {
		m.missCount++
	}
	return args.Get(0), args.Error(1)
}

// Set mocks setting a value in cache
func (m *MockCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.setCount++
	m.data[key] = value

	args := m.Called(ctx, key, value, ttl)
	return args.Error(0)
}

// Delete mocks deleting a value from cache
func (m *MockCache) Delete(ctx context.Context, key string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	delete(m.data, key)
	args := m.Called(ctx, key)
	return args.Error(0)
}

// HitCount returns the number of cache hits
func (m *MockCache) HitCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.hitCount
}

// MissCount returns the number of cache misses
func (m *MockCache) MissCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.missCount
}

// SetCount returns the number of cache sets
func (m *MockCache) SetCount() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.setCount
}

// HitRate returns the cache hit rate
func (m *MockCache) HitRate() float64 {
	m.mu.RLock()
	defer m.mu.RUnlock()

	total := m.hitCount + m.missCount
	if total == 0 {
		return 0
	}
	return float64(m.hitCount) / float64(total)
}

// Reset clears all tracked data
func (m *MockCache) Reset() {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.data = make(map[string]interface{})
	m.hitCount = 0
	m.missCount = 0
	m.setCount = 0
}
