// =============================================================================
// Test Fixtures - Package Documentation & Helpers
// =============================================================================
//
// {{.ProjectName}} - Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
//
// Package fixtures provides test data and utilities for testing the
// {{.ProjectName}} service. It includes sample data for:
//
//   - Entities: Valid and invalid entity scenarios
//   - Configuration: Various service configuration options
//   - Credentials: Test credentials and authentication data
//   - Responses: Mock HTTP responses
//
// =============================================================================

package fixtures

import (
	"encoding/json"
	"os"
	"path/filepath"
	"runtime"
	"time"

	"github.com/google/uuid"
)

// =============================================================================
// Directory & File Helpers
// =============================================================================

// FixturesDir returns the path to the fixtures directory
func FixturesDir() string {
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return ""
	}
	return filepath.Dir(filename)
}

// LoadJSONFixture loads a JSON fixture file and unmarshals it into the target
func LoadJSONFixture(filename string, target interface{}) error {
	path := filepath.Join(FixturesDir(), filename)
	data, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	return json.Unmarshal(data, target)
}

// =============================================================================
// Temporary File Helpers
// =============================================================================

// CreateTempFile creates a temporary file with the given content
func CreateTempFile(prefix, content string) (string, func(), error) {
	tmpDir, err := os.MkdirTemp("", "{{.ProjectName}}-test-*")
	if err != nil {
		return "", nil, err
	}

	filePath := filepath.Join(tmpDir, prefix)
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		_ = os.RemoveAll(tmpDir)
		return "", nil, err
	}

	cleanup := func() {
		_ = os.RemoveAll(tmpDir)
	}

	return filePath, cleanup, nil
}

// CreateTempEnvFile creates a temporary .env file with the given content
func CreateTempEnvFile(content string) (string, func(), error) {
	return CreateTempFile(".env", content)
}

// CreateTempConfigFile creates a temporary config file with the given content
func CreateTempConfigFile(filename, content string) (string, func(), error) {
	return CreateTempFile(filename, content)
}

// =============================================================================
// Environment Variable Helpers
// =============================================================================

// SetEnvVars sets environment variables and returns a cleanup function
func SetEnvVars(vars map[string]string) func() {
	original := make(map[string]string)

	for key, value := range vars {
		original[key] = os.Getenv(key)
		_ = os.Setenv(key, value)
	}

	return func() {
		for key, value := range original {
			if value == "" {
				_ = os.Unsetenv(key)
			} else {
				_ = os.Setenv(key, value)
			}
		}
	}
}

// DefaultEnvVars returns a map of default environment variables for testing
func DefaultEnvVars() map[string]string {
	return map[string]string{
		"{{.EnvPrefix}}_DB_HOST":     "localhost",
		"{{.EnvPrefix}}_DB_PORT":     "5432",
		"{{.EnvPrefix}}_DB_NAME":     "{{.ProjectName}}_test",
		"{{.EnvPrefix}}_DB_USER":     "test",
		"{{.EnvPrefix}}_DB_PASSWORD": "test",
		"{{.EnvPrefix}}_PORT":        "8080",
		"{{.EnvPrefix}}_ENV":         "test",
		"{{.EnvPrefix}}_LOG_LEVEL":   "debug",
	}
}

// =============================================================================
// Entity Fixtures
// =============================================================================

// EntityFixture represents an entity test fixture
type EntityFixture struct {
	ID          uuid.UUID
	Name        string
	Description string
	Status      string
	Metadata    map[string]interface{}
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// SampleEntities contains sample entity fixtures
var SampleEntities = []EntityFixture{
	{
		ID:          uuid.MustParse("00000000-0000-0000-0000-000000000001"),
		Name:        "Sample Entity 1",
		Description: "First sample entity for testing",
		Status:      "active",
		Metadata: map[string]interface{}{
			"category": "test",
			"priority": 1,
		},
		CreatedAt: time.Now().Add(-24 * time.Hour),
		UpdatedAt: time.Now().Add(-1 * time.Hour),
	},
	{
		ID:          uuid.MustParse("00000000-0000-0000-0000-000000000002"),
		Name:        "Sample Entity 2",
		Description: "Second sample entity for testing",
		Status:      "inactive",
		Metadata: map[string]interface{}{
			"category": "demo",
			"priority": 2,
		},
		CreatedAt: time.Now().Add(-48 * time.Hour),
		UpdatedAt: time.Now().Add(-2 * time.Hour),
	},
	{
		ID:          uuid.MustParse("00000000-0000-0000-0000-000000000003"),
		Name:        "Sample Entity 3",
		Description: "Third sample entity for testing",
		Status:      "pending",
		Metadata: map[string]interface{}{
			"category": "production",
			"priority": 3,
		},
		CreatedAt: time.Now().Add(-72 * time.Hour),
		UpdatedAt: time.Now().Add(-3 * time.Hour),
	},
}

// GetSampleEntity returns a single sample entity
func GetSampleEntity() *EntityFixture {
	if len(SampleEntities) == 0 {
		return nil
	}
	entity := SampleEntities[0]
	return &entity
}

// GetSampleEntities returns multiple sample entities
func GetSampleEntities(count int) []EntityFixture {
	if count <= 0 {
		return nil
	}
	if count > len(SampleEntities) {
		count = len(SampleEntities)
	}
	return SampleEntities[:count]
}

// GetSampleEntityData returns entity data as a map (for JSON requests)
func GetSampleEntityData() map[string]interface{} {
	return map[string]interface{}{
		"name":        "Test Entity",
		"description": "Entity created for testing",
		"status":      "active",
		"metadata": map[string]interface{}{
			"category": "test",
			"priority": 1,
		},
	}
}

// GetEntitiesByStatus returns entities filtered by status
func GetEntitiesByStatus(status string) []EntityFixture {
	var result []EntityFixture
	for _, e := range SampleEntities {
		if e.Status == status {
			result = append(result, e)
		}
	}
	return result
}

// =============================================================================
// Credential Fixtures
// =============================================================================

// ValidCredentials contains valid test credentials
var ValidCredentials = struct {
	Username string
	Password string
	APIKey   string
	Token    string
}{
	Username: "test_user",
	Password: "test_password_12345",
	APIKey:   "api_key_test_valid_12345",
	Token:    "jwt_token_test_valid_67890",
}

// InvalidCredentials contains various invalid credential scenarios
var InvalidCredentials = []struct {
	Name     string
	Username string
	Password string
	Error    string
}{
	{
		Name:     "empty_username",
		Username: "",
		Password: "valid_password",
		Error:    "username cannot be empty",
	},
	{
		Name:     "empty_password",
		Username: "valid_user",
		Password: "",
		Error:    "password cannot be empty",
	},
	{
		Name:     "both_empty",
		Username: "",
		Password: "",
		Error:    "username cannot be empty",
	},
	{
		Name:     "password_too_short",
		Username: "valid_user",
		Password: "123",
		Error:    "password is too short",
	},
	{
		Name:     "username_too_long",
		Username: string(make([]byte, 256)),
		Password: "valid_password",
		Error:    "username exceeds maximum length",
	},
}

// =============================================================================
// HTTP Response Fixtures
// =============================================================================

// HTTPResponseFixture represents an HTTP response fixture
type HTTPResponseFixture struct {
	StatusCode int
	Headers    map[string]string
	Body       interface{}
}

// SuccessResponse returns a standard success response
func SuccessResponse(data interface{}) HTTPResponseFixture {
	return HTTPResponseFixture{
		StatusCode: 200,
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
		Body: map[string]interface{}{
			"success": true,
			"data":    data,
		},
	}
}

// ErrorResponse returns a standard error response
func ErrorResponse(statusCode int, message string) HTTPResponseFixture {
	return HTTPResponseFixture{
		StatusCode: statusCode,
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
		Body: map[string]interface{}{
			"success": false,
			"error": map[string]interface{}{
				"code":    statusCode,
				"message": message,
			},
		},
	}
}

// PaginatedResponse returns a paginated response
func PaginatedResponse(data interface{}, total, offset, limit int) HTTPResponseFixture {
	return HTTPResponseFixture{
		StatusCode: 200,
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
		Body: map[string]interface{}{
			"success": true,
			"data":    data,
			"meta": map[string]interface{}{
				"total":  total,
				"offset": offset,
				"limit":  limit,
			},
		},
	}
}

// =============================================================================
// Configuration Fixtures
// =============================================================================

// ConfigFixture represents a configuration fixture
type ConfigFixture struct {
	Name        string
	Environment string
	Port        int
	Database    DatabaseConfig
	Cache       CacheConfig
	Auth        AuthConfig
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
	Host     string
	Port     int
	Name     string
	User     string
	Password string
	SSLMode  string
}

// CacheConfig represents cache configuration
type CacheConfig struct {
	Enabled bool
	Host    string
	Port    int
	TTL     int
}

// AuthConfig represents authentication configuration
type AuthConfig struct {
	Enabled     bool
	JWTSecret   string
	TokenExpiry int
}

// DefaultConfig returns the default configuration for testing
func DefaultConfig() ConfigFixture {
	return ConfigFixture{
		Name:        "{{.ProjectName}}",
		Environment: "test",
		Port:        8080,
		Database: DatabaseConfig{
			Host:     "localhost",
			Port:     5432,
			Name:     "{{.ProjectName}}_test",
			User:     "test",
			Password: "test",
			SSLMode:  "disable",
		},
		Cache: CacheConfig{
			Enabled: true,
			Host:    "localhost",
			Port:    6379,
			TTL:     300,
		},
		Auth: AuthConfig{
			Enabled:     true,
			JWTSecret:   "test-jwt-secret-key-12345",
			TokenExpiry: 3600,
		},
	}
}

// InvalidConfigs contains various invalid configuration scenarios
var InvalidConfigs = []struct {
	Name   string
	Config ConfigFixture
	Error  string
}{
	{
		Name: "invalid_port",
		Config: ConfigFixture{
			Port: -1,
		},
		Error: "invalid port number",
	},
	{
		Name: "missing_database_host",
		Config: ConfigFixture{
			Port: 8080,
			Database: DatabaseConfig{
				Host: "",
				Port: 5432,
			},
		},
		Error: "database host cannot be empty",
	},
	{
		Name: "invalid_database_port",
		Config: ConfigFixture{
			Port: 8080,
			Database: DatabaseConfig{
				Host: "localhost",
				Port: 0,
			},
		},
		Error: "invalid database port",
	},
}

// =============================================================================
// Validation Test Cases
// =============================================================================

// ValidationTestCase represents a validation test case
type ValidationTestCase struct {
	Name        string
	Input       interface{}
	ExpectError bool
	ErrorMsg    string
}

// EntityValidationCases returns validation test cases for entities
func EntityValidationCases() []ValidationTestCase {
	return []ValidationTestCase{
		{
			Name:        "valid entity",
			Input:       GetSampleEntityData(),
			ExpectError: false,
		},
		{
			Name: "missing name",
			Input: map[string]interface{}{
				"description": "Description only",
			},
			ExpectError: true,
			ErrorMsg:    "name is required",
		},
		{
			Name: "empty name",
			Input: map[string]interface{}{
				"name": "",
			},
			ExpectError: true,
			ErrorMsg:    "name cannot be empty",
		},
		{
			Name: "name too long",
			Input: map[string]interface{}{
				"name": string(make([]byte, 256)),
			},
			ExpectError: true,
			ErrorMsg:    "name exceeds maximum length",
		},
	}
}

// =============================================================================
// Time Helpers
// =============================================================================

// TestTime returns a consistent time for testing
func TestTime() time.Time {
	return time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)
}

// TimeBeforeNow returns a time before the current time
func TimeBeforeNow(duration time.Duration) time.Time {
	return time.Now().Add(-duration)
}

// TimeAfterNow returns a time after the current time
func TimeAfterNow(duration time.Duration) time.Time {
	return time.Now().Add(duration)
}

// =============================================================================
// UUID Helpers
// =============================================================================

// ValidUUIDs contains valid UUIDs for testing
var ValidUUIDs = []uuid.UUID{
	uuid.MustParse("00000000-0000-0000-0000-000000000001"),
	uuid.MustParse("00000000-0000-0000-0000-000000000002"),
	uuid.MustParse("00000000-0000-0000-0000-000000000003"),
	uuid.MustParse("00000000-0000-0000-0000-000000000004"),
	uuid.MustParse("00000000-0000-0000-0000-000000000005"),
}

// InvalidUUIDStrings contains invalid UUID strings for testing
var InvalidUUIDStrings = []string{
	"",
	"not-a-uuid",
	"00000000-0000-0000-0000",
	"00000000-0000-0000-0000-00000000000g",
	"00000000000000000000000000000001",
}

// GetRandomUUID returns a random valid UUID from the fixtures
func GetRandomUUID() uuid.UUID {
	if len(ValidUUIDs) == 0 {
		return uuid.New()
	}
	return ValidUUIDs[0]
}

// =============================================================================
// JSON Helpers
// =============================================================================

// ToJSON converts an interface to JSON string
func ToJSON(v interface{}) string {
	data, err := json.Marshal(v)
	if err != nil {
		return "{}"
	}
	return string(data)
}

// FromJSON parses a JSON string into the target
func FromJSON(jsonStr string, target interface{}) error {
	return json.Unmarshal([]byte(jsonStr), target)
}

// PrettyJSON returns a pretty-printed JSON string
func PrettyJSON(v interface{}) string {
	data, err := json.MarshalIndent(v, "", "  ")
	if err != nil {
		return "{}"
	}
	return string(data)
}
